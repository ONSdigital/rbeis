
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>rbeis.pandas &#8212; rbeis 0.0.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex/" />
    <link rel="search" title="Search" href="../../../search/" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex/" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../">rbeis 0.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">rbeis.pandas</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for rbeis.pandas</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">RBEIS for Pandas.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">Fraction</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="k">import</span> <span class="n">choice</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="k">import</span> <span class="n">shuffle</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Number</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">ast</span> <span class="k">import</span> <span class="n">literal_eval</span>
<span class="kn">from</span> <span class="nn">re</span> <span class="k">import</span> <span class="n">sub</span>


<div class="viewcode-block" id="RBEISInputException"><a class="viewcode-back" href="../../../autoapi/rbeis/pandas/#rbeis.pandas.RBEISInputException">[docs]</a><span class="k">class</span> <span class="nc">RBEISInputException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Exception raised in the case of faulty input to `impute` that is not covered by a TypeError.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="RBEISInputWarning"><a class="viewcode-back" href="../../../autoapi/rbeis/pandas/#rbeis.pandas.RBEISInputWarning">[docs]</a><span class="k">class</span> <span class="nc">RBEISInputWarning</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Warning raised in the case of redundant input to `impute`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="RBEISDistanceFunction"><a class="viewcode-back" href="../../../autoapi/rbeis/pandas/#rbeis.pandas.RBEISDistanceFunction">[docs]</a><span class="k">class</span> <span class="nc">RBEISDistanceFunction</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Callable object encapsulating one of the six RBEIS distance functions, its</span>
<span class="sd">    threshold value (where appropriate), any pairs of values to be overridden</span>
<span class="sd">    (for DFs 4-6), and a weight by which to scale its result.</span>

<span class="sd">    PLEASE NOTE that, in rbeis._calc_distances, the argument order is assumed to</span>
<span class="sd">    be (record, IGroup).  This is especially important when defining custom maps</span>
<span class="sd">    for DFs 4-6, which *do not* assume that f(x,y) == f(y,x).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Standard distance functions 1-3 (4-6 are 1-3 with custom overrides)</span>
    <span class="c1"># Where x is the IGroup&#39;s value, y is the current record&#39;s value, and m is a threshold value</span>
    <span class="k">def</span> <span class="nf">_df1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        _df1(x, y)</span>

<span class="sd">        x (&#39;a): A data point for comparison</span>
<span class="sd">        y (&#39;a): A data point for comparison</span>

<span class="sd">        Distance Function 1: return 1 if x and y are not equal, otherwise 0.</span>
<span class="sd">        This function (and its derivative, DF4) can be used with any data types</span>
<span class="sd">        that are comparable using =.</span>

<span class="sd">        e.g. _df1(2, 2) =&gt; 0</span>
<span class="sd">             _df1(2, 4) =&gt; 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_df2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        _df2(x, y, m)</span>

<span class="sd">        x (numeric): A data point for comparison</span>
<span class="sd">        y (numeric): A data point for comparison</span>
<span class="sd">        m (numeric): A threshold value</span>

<span class="sd">        Distance Function 2: return 1 if the difference between x and y is</span>
<span class="sd">        greater than the threshold m, otherwise 0.  This function (and its</span>
<span class="sd">        derivative, DF5) may only be used with numeric data.</span>

<span class="sd">        e.g. _df2(2, 2, 2) =&gt; 0</span>
<span class="sd">             _df2(2, 3, 2) =&gt; 0</span>
<span class="sd">             _df2(2, 8, 2) =&gt; 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Number</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;You have tried to call distance function 2, 3, 5 or 6, but your data is not numeric&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Number</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;You have provided a non-numeric threshold value to distance function 2, 3, 5 or 6&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_df3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        _df3(x, y, m)</span>

<span class="sd">        x (numeric): A data point for comparison</span>
<span class="sd">        y (numeric): A data point for comparison</span>
<span class="sd">        m (numeric): A threshold value</span>

<span class="sd">        Distance Function 3: return 1 if the difference between x and y is</span>
<span class="sd">        greater than the threshold m, otherwise return the difference between x</span>
<span class="sd">        and y, divided by m + 1.  This function (and its derivative, DF6) may</span>
<span class="sd">        only be used with numeric data.</span>

<span class="sd">        e.g. _df3(2, 2, 3) =&gt; 0</span>
<span class="sd">             _df3(2, 3, 3) =&gt; 0.25</span>
<span class="sd">             _df3(2, 8, 3) =&gt; 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Number</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;You have tried to call distance function 2, 3, 5 or 6, but your data is not numeric&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Number</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;You have provided a non-numeric threshold value to distance function 2, 3, 5 or 6&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">m</span> <span class="k">else</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">_df1</span>
<div class="viewcode-block" id="RBEISDistanceFunction.weight"><a class="viewcode-back" href="../../../autoapi/rbeis/pandas/#rbeis.pandas.RBEISDistanceFunction.weight">[docs]</a>    <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">custom_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        RBEISDistanceFunction(df, custom_map=None, threshold=None, weight=1.0)</span>

<span class="sd">                                     df (int): An integer from 1 to 6</span>
<span class="sd">                                               corresponding to one of the</span>
<span class="sd">                                               standard RBEIS distance functions</span>
<span class="sd">        custom_map ((&#39;a * &#39;a) * numeric dict): [Optional] A dictionary mapping</span>
<span class="sd">                                               pairs (2-tuples) of values to</span>
<span class="sd">                                               distances (value pair as key,</span>
<span class="sd">                                               distance as value), overriding</span>
<span class="sd">                                               the underlying standard distance</span>
<span class="sd">                                               function.  Note that (x,y) -&gt; z</span>
<span class="sd">                                               does not imply that (y,x) -&gt; z.</span>
<span class="sd">                                               This is required for distance</span>
<span class="sd">                                               functions 4, 5 and 6.</span>
<span class="sd">                          threshold (numeric): [Optional] A threshold value for</span>
<span class="sd">                                               distance functions 2, 3, 5 and 6.</span>
<span class="sd">                             weight (numeric): [Optional] A weight value by</span>
<span class="sd">                                               which to scale the output of the</span>
<span class="sd">                                               distance function</span>

<span class="sd">        Initialise a new RBEISDistanceFunction object with the above parameters.</span>

<span class="sd">        e.g. myDF = RBEISDistanceFunction(6,</span>
<span class="sd">                                          custom_map = {(2, 3): 4, (8, 8): 0.25},</span>
<span class="sd">                                          threshold = 3,</span>
<span class="sd">                                          weight = 10)</span>
<span class="sd">             myDF(2, 2) =&gt; 0</span>
<span class="sd">             myDF(2, 4) =&gt; 5</span>
<span class="sd">             myDF(2, 8) =&gt; 10</span>
<span class="sd">             myDF(2, 3) =&gt; 40</span>
<span class="sd">             myDF(8, 8) =&gt; 2.5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">df</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">df</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RBEISInputException</span><span class="p">(</span>
                <span class="s2">&quot;The distance function must be an integer from 1 to 6 inclusive&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">df</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">threshold</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="n">Number</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;Distance function thresholds must be a numeric type&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">RBEISInputException</span><span class="p">(</span>
                    <span class="s2">&quot;The chosen distance function requires a threshold value&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;You have supplied a threshold value for a distance function that does not require one&quot;</span><span class="p">,</span>
                <span class="n">RBEISInputWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">df</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">custom_map</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span>
                        <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span>
                            <span class="n">custom_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()))):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;Distance function overrides must be expressed in a dictionary whose keys are tuples representing pairs of values&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span>
                        <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Number</span><span class="p">),</span>
                            <span class="n">custom_map</span><span class="o">.</span><span class="n">values</span><span class="p">()))):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;Distance function overrides must be expressed in a dictionary whose values are numeric&quot;</span>
                    <span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">RBEISInputException</span><span class="p">(</span>
                    <span class="s2">&quot;You have chosen a distance funtion with overrides, but have not provided them&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">custom_map</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;You have supplied custom mappings for a distance function that does not use them&quot;</span><span class="p">,</span>
                <span class="n">RBEISInputWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">Number</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;You have supplied a weight that is not numeric&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">df</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_df1</span>
        <span class="k">elif</span> <span class="n">df</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_df2</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">df</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_df3</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">df</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">custom_map</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
                      <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">custom_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_df1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">df</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">custom_map</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">custom_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_df2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">threshold</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">df</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">custom_map</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)])</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">custom_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_df3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">threshold</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_check_missing_auxvars</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">aux_vars</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    _check_missing_auxvars(data, aux_vars)</span>


<span class="sd">                                  data (pd.DataFrame): The dataset undergoing</span>
<span class="sd">                                                       imputation</span>
<span class="sd">          aux_vars (str * RBEISDistanceFunction dict): A dictionary whose keys</span>
<span class="sd">                                                       are strings corresponding</span>
<span class="sd">                                                       to the names of auxiliary</span>
<span class="sd">                                                       variables and whose values</span>
<span class="sd">                                                       are the</span>
<span class="sd">                                                       RBEISDistanceFunctions to</span>
<span class="sd">                                                       be used to compare</span>
<span class="sd">                                                       instances of each</span>
<span class="sd">                                                       auxiliary variable.</span>

<span class="sd">    Raise an RBEISInputException if the DataFrame contains any records for which</span>
<span class="sd">    any of the chosen auxiliary variables are missing.</span>

<span class="sd">    e.g. _check_missing_auxvars(pd.read_csv(&quot;my_data.csv&quot;),</span>
<span class="sd">                                {&quot;height&quot;: RBEISDistanceFunction(1,</span>
<span class="sd">                                                                 weight = 5),</span>
<span class="sd">                                 &quot;length&quot;: RBEISDistanceFunction(5,</span>
<span class="sd">                                                                 custom_map = {(2, 3): 0,</span>
<span class="sd">                                                                               (8, 8): 0.25},</span>
<span class="sd">                                                                 threshold = 2)})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">any</span><span class="p">([</span>
            <span class="nb">any</span><span class="p">(</span>
                <span class="nb">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                <span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">aux_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">]))</span>
    <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">RBEISInputException</span><span class="p">(</span>
            <span class="s2">&quot;Your dataset includes records for which the given auxiliary variables are missing&quot;</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">_add_impute_col</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">imp_var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    _add_impute_col(data, imp_var)</span>

<span class="sd">    data (pd.DataFrame): The dataset undergoing imputation</span>
<span class="sd">          imp_var (str): The name of the variable to be imputed</span>

<span class="sd">    Prepare the DataFrame by adding a boolean column &#39;_impute&#39; indicating</span>
<span class="sd">    whether or not a record is to be imputed.  A record will be marked for</span>
<span class="sd">    imputation if a value for the specified imputation variable is missing.</span>
<span class="sd">    This function modifies the DataFrame in place, rather than returning a</span>
<span class="sd">    new DataFrame.</span>

<span class="sd">    e.g. _add_impute_col(pd.read_csv(&quot;my_data.csv&quot;), &quot;length&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note that data[&quot;_impute&quot;] = np.isnan(data[imp_var]) does not work when imp_var is non-numeric</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_impute&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">imp_var</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">imp_var</span><span class="p">],</span> <span class="n">Number</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_assign_igroups</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">aux_var_names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    _assign_igroups(data, aux_var_names)</span>

<span class="sd">         data (pd.DataFrame): The dataset undergoing imputation</span>
<span class="sd">    aux_var_names (str list): The names of the chosen auxiliary variables</span>

<span class="sd">    Add a column &#39;IGroup&#39; containing integers representing the IGroup that each</span>
<span class="sd">    recipient record is assigned to.  This function modifies the DataFrame in</span>
<span class="sd">    place, rather than returning a new DataFrame.</span>
<span class="sd">    1. Add a column &#39;_conc_aux&#39; containing the string representation of the list</span>
<span class="sd">       of values corresponding to the record&#39;s auxiliary variables</span>
<span class="sd">    2. Group by &#39;_conc_aux&#39; and extract group integers from the internal grouper</span>
<span class="sd">       object, creating a new column &#39;_IGroup&#39; containing these integers</span>
<span class="sd">    3. Subtract 1 from each IGroup value, giving -1 for all non-recipient</span>
<span class="sd">       records and zero-indexing all others</span>
<span class="sd">    4. Remove column &#39;_conc_aux&#39;</span>

<span class="sd">    e.g. _assign_igroups(myDataFrame, [&quot;height&quot;, &quot;width&quot;, &quot;length&quot;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_conc_aux&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">r</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">aux_var_names</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="s2">&quot;_impute&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_IGroup&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;_conc_aux&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">group_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_IGroup&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span><span class="p">[</span><span class="s2">&quot;_IGroup&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_conc_aux&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_get_igroup_aux_var</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">aux_var_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    _get_igroup_aux_var(data, aux_var_name)</span>

<span class="sd">    data (pd.DataFrame): The dataset undergoing imputation</span>
<span class="sd">     aux_var_name (str): The name of the desired auxiliary variable</span>

<span class="sd">    Return a list containing each IGroup&#39;s value of a given auxiliary variable.</span>
<span class="sd">    The value at index i corresponds to the value for IGroup i.</span>

<span class="sd">    e.g. _get_igroup_aux_var(myDataFrame, &quot;height&quot;) =&gt; [188, 154, 192, ...]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_IGroup&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()):</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="p">(</span><span class="n">data</span><span class="p">[[</span>
            <span class="s2">&quot;_IGroup&quot;</span><span class="p">,</span> <span class="n">aux_var_name</span>
        <span class="p">]]</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;_IGroup == &quot;</span> <span class="o">+</span>
                                   <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))[</span><span class="n">aux_var_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_calc_distances</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">aux_vars</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    _calc_distances(data, aux_vars)</span>

<span class="sd">                            data (pd.DataFrame): The dataset undergoing</span>
<span class="sd">                                                 imputation</span>
<span class="sd">    aux_vars (str * RBEISDistanceFunction dict): A dictionary whose keys are</span>
<span class="sd">                                                 strings corresponding to the</span>
<span class="sd">                                                 names of auxiliary variables</span>
<span class="sd">                                                 and whose values are the</span>
<span class="sd">                                                 RBEISDistanceFunctions to be</span>
<span class="sd">                                                 used to compare instances of</span>
<span class="sd">                                                 each auxiliary variable.</span>

<span class="sd">    Add a column &#39;_distances&#39; containing lists of calculated distances of each</span>
<span class="sd">    record&#39;s auxiliary variables from those of its IGroup.  This function</span>
<span class="sd">    modifies the DataFrame in place, rather than returning a new DataFrame.</span>
<span class="sd">    1. Create a list of dictionaries containing the values of each IGroup&#39;s</span>
<span class="sd">       auxiliary variables</span>
<span class="sd">    2. Add a column &#39;_dists_temp&#39; containing, for each potential donor record, a</span>
<span class="sd">       list of dictionaries of calculated distances for each auxiliary variable</span>
<span class="sd">    3. Add a column &#39;_distances&#39; containing, for each potential donor record, a</span>
<span class="sd">       list of calculated distances from its IGroup&#39;s auxiliary variables,</span>
<span class="sd">       taking into account the specified weights</span>
<span class="sd">    4. Remove column &#39;_dists_temp&#39;</span>

<span class="sd">    PLEASE NOTE that the argument order is assumed to be (record, IGroup).  This</span>
<span class="sd">    is especially important when using custom maps with distance functions 4-6,</span>
<span class="sd">    which *do not* assume that f(x,y) == f(y,x).</span>

<span class="sd">    e.g. _calc_distances(myDataFrame, {&quot;length&quot;: RBEISDistanceFunction(2, threshold=1.5),</span>
<span class="sd">                                       &quot;genre&quot;: RBEISDistanceFunction(1, weight=8),</span>
<span class="sd">                                       &quot;rating&quot;: RBEISDistanceFunction(4, custom_map={(3,4): 0,</span>
<span class="sd">                                                                                      (1,1): 10}})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">igroup_aux_vars</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">vars_vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span>
            <span class="n">aux_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">_get_igroup_aux_var</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">aux_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
        <span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_IGroup&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()):</span>
        <span class="n">igroup_aux_vars</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vars_vals</span><span class="p">})</span>

    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_dists_temp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="p">{</span>
                    <span class="n">k</span><span class="p">:</span> <span class="n">aux_vars</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">igroup_aux_vars</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">aux_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="p">},</span>
                <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_IGroup&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span>
            <span class="p">))</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s2">&quot;_impute&quot;</span><span class="p">])</span> <span class="k">else</span> <span class="p">[],</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_distances&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">r</span><span class="p">[</span><span class="s2">&quot;_dists_temp&quot;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s2">&quot;_impute&quot;</span><span class="p">])</span> <span class="k">else</span> <span class="p">[],</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_dists_temp&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_calc_donors</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    _calc_donors(data, ratio=None)</span>

<span class="sd">    data (pd.DataFrame): The dataset undergoing imputation</span>
<span class="sd">        ratio (numeric): [Optional] Instead of choosing the minimum distance,</span>
<span class="sd">                         choose records less than or equal to ratio * the</span>
<span class="sd">                         minimum distance.</span>

<span class="sd">    Add a column &#39;donor&#39; containing a list of IGroup numbers to which each</span>
<span class="sd">    record is a donor.  This function modifies the DataFrame in place, rather</span>
<span class="sd">    than returning a new DataFrame.</span>
<span class="sd">    1. Calculate the distances less than or equal to which a record may be</span>
<span class="sd">       accepted as a donor to each respective IGroup.</span>
<span class="sd">    2. Zip each record&#39;s distances to the list of distances calculated in step</span>
<span class="sd">       1, and identify where the record distances are less than or equal to the</span>
<span class="sd">       maximum required IGroup distances, giving a list of indices where this is</span>
<span class="sd">       the case.</span>

<span class="sd">    e.g. _calc_donors(myDataFrame)</span>
<span class="sd">         _calc_donors(myDataFrame, ratio=2.5)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ratio</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">ratio</span><span class="o">&gt;=</span><span class="mi">1</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RBEISInputException</span><span class="p">(</span><span class="s2">&quot;You have provided a ratio value of less than 1, meaning that RBEIS would be looking for distances less than the minimum&quot;</span><span class="p">)</span>
    <span class="n">igroups_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">data</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;not(_impute)&quot;</span><span class="p">)[</span><span class="s2">&quot;_distances&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">max_donor_dists</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="nb">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">max</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">l</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">ratio</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">)])</span>
            <span class="k">if</span> <span class="n">ratio</span> <span class="k">else</span> <span class="nb">min</span><span class="p">(</span><span class="n">l</span><span class="p">),</span>
            <span class="n">igroups_dists</span><span class="p">,</span>
        <span class="p">))</span>
    <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_donor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span>
                <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s2">&quot;_distances&quot;</span><span class="p">],</span> <span class="n">max_donor_dists</span><span class="p">))))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s2">&quot;_impute&quot;</span><span class="p">])</span> <span class="k">else</span> <span class="p">[],</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>  <span class="c1"># TODO: What if we have multiple minima?  Do we just choose the first, or choose one randomly?</span>


<span class="k">def</span> <span class="nf">_get_donors</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">igroup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    _get_donors(data, igroup)</span>

<span class="sd">    data (pd.DataFrame): The dataset undergoing imputation</span>
<span class="sd">           igroup (int): The IGroup whose donors are required</span>

<span class="sd">    Return a list of indices corresponding to records in data that are donors to</span>
<span class="sd">    the specified IGroup.</span>

<span class="sd">    e.g. _get_donors(myDataFrame, 24) =&gt; [10, 14, 29, ...]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">igroup</span> <span class="ow">in</span> <span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_donor&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>


<span class="k">def</span> <span class="nf">_get_freq_dist</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">imp_var</span><span class="p">,</span> <span class="n">possible_vals</span><span class="p">,</span> <span class="n">igroup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    _get_freq_dist(data, imp_var, possible_vals, igroup)</span>

<span class="sd">        data (pd.DataFrame): The dataset undergoing imputation</span>
<span class="sd">              imp_var (str): The name of the variable to be imputed</span>
<span class="sd">    possible_vals (&#39;a list): A list of all possible values that imp_var can take</span>
<span class="sd">               igroup (int): The IGroup whose donors are required</span>

<span class="sd">    For a given IGroup, return a frequency distribution for each possible value</span>
<span class="sd">    of the variable to be imputed.  This takes the form of a list of the</span>
<span class="sd">    proportions of a given IGroup taken up by each possible value.</span>

<span class="sd">    e.g. _get_freq_fist(myDataFrame, &quot;genre&quot;, [&quot;jungle&quot;, &quot;acid house&quot;, &quot;UK garage&quot;], 48) =&gt; [0.5, 0.3, 0.2]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">_get_donors</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">igroup</span><span class="p">)][</span><span class="n">imp_var</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
        <span class="nb">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pool</span><span class="p">)),</span>
            <span class="nb">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="nb">len</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pool</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">v</span><span class="p">]),</span>
                <span class="n">possible_vals</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">))</span>


<span class="k">def</span> <span class="nf">_freq_to_exp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">freq_dist</span><span class="p">,</span> <span class="n">igroup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    _freq_to_exp(data, freq_dist, igroup)</span>

<span class="sd">          data (pd.DataFrame): The dataset undergoing imputation</span>
<span class="sd">    freq_dist (Fraction list): The frequency distribution to convert</span>
<span class="sd">                 igroup (int): The IGroup corresponding to freq_dist</span>

<span class="sd">    Convert a frequency distribution to the expected numbers of occurrences for</span>
<span class="sd">    a given IGroup.</span>

<span class="sd">    e.g. _freq_to_exp(myDataFrame, [0.5, 0.3, 0.2], 48) =&gt; [100, 60, 40]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">igroup_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;_IGroup==&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">igroup</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span> <span class="o">*</span> <span class="n">igroup_size</span><span class="p">,</span> <span class="n">freq_dist</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_impute_igroup</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">exp_dist</span><span class="p">,</span> <span class="n">possible_vals</span><span class="p">,</span> <span class="n">igroup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    _impute_igroup(data, exp_dist, possible_vals, igroup)</span>

<span class="sd">         data (pd.DataFrame): The dataset undergoing imputation</span>
<span class="sd">    exp_dist (Fraction list): The expected values derived from the frequency</span>
<span class="sd">                              distribution using _freq_to_exp</span>
<span class="sd">     possible_vals (&#39;a list): A list of all possible values that imp_var can take</span>
<span class="sd">                igroup (int): The IGroup whose values are to be imputed</span>

<span class="sd">    Return a set of imputed values for the given IGroup:</span>
<span class="sd">    1. For each of the possible values that the variable to be imputed can take,</span>
<span class="sd">       insert a number of values equal to the integer part of the expected value</span>
<span class="sd">       and subtract the integer part from the expected value</span>
<span class="sd">    2. Convert the fractional parts of the expected values back into</span>
<span class="sd">       probabilities</span>
<span class="sd">    3. Using these probabilities, draw a value at random, remove that value from</span>
<span class="sd">       the set of possible values to be imputed, and adjust the remaining</span>
<span class="sd">       probabilities accordingly</span>
<span class="sd">    4. Repeat step 3 until there are no more values still to impute</span>
<span class="sd">    5. Randomise the order of the list of imputed values, then return it</span>

<span class="sd">    e.g. _impute_igroup(myDataFrame, [100, 60, 40], [&quot;jungle&quot;, &quot;acid house&quot;, &quot;UK garage&quot;], 48)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">exp_dist</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="n">igroup_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;_IGroup==&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">igroup</span><span class="p">))</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">exp_dist</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">exp_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">possible_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">exp_dist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">exp_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="nb">int</span><span class="p">(</span><span class="n">exp_dist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">remaining</span> <span class="o">=</span> <span class="n">igroup_size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">remaining</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">exp_dist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">exp_dist</span><span class="p">)),</span> <span class="n">exp_dist</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="n">exp_dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">possible_vals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">possible_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">exp_dist</span><span class="p">))</span> <span class="k">if</span> <span class="n">exp_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">]</span>
        <span class="n">exp_dist</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">exp_dist</span> <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">remaining</span><span class="p">):</span>
            <span class="n">selected_val</span> <span class="o">=</span> <span class="n">choice</span><span class="p">(</span><span class="n">possible_vals</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">exp_dist</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">exp_dist</span><span class="p">[</span><span class="n">possible_vals</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">selected_val</span><span class="p">)]</span>
            <span class="n">exp_dist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">Fraction</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">exp_dist</span><span class="p">)),</span>
                                <span class="n">exp_dist</span><span class="p">))</span>
            <span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="n">exp_dist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="n">possible_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">possible_vals</span> <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">selected_val</span><span class="p">]</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">selected_val</span><span class="p">)</span>
        <span class="c1"># TODO: check that number of imputed values for each possible value is</span>
        <span class="c1">#       either int(exp) or int(exp)+1</span>
    <span class="n">shuffle</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<div class="viewcode-block" id="impute"><a class="viewcode-back" href="../../../autoapi/rbeis/pandas/#rbeis.pandas.impute">[docs]</a><span class="k">def</span> <span class="nf">impute</span><span class="p">(</span>
    <span class="n">data</span><span class="p">,</span>
    <span class="n">imp_var</span><span class="p">,</span>
    <span class="n">possible_vals</span><span class="p">,</span>
    <span class="n">aux_vars</span><span class="p">,</span>
    <span class="n">ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">keep_intermediates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    impute(data, imp_var, possible_vals, aux_vars, ratio=None, in_place=True,</span>
<span class="sd">           keep_intermediates=False)</span>

<span class="sd">                            data (pd.DataFrame): The dataset undergoing</span>
<span class="sd">                                                 imputation</span>
<span class="sd">                                  imp_var (str): The name of the variable to be</span>
<span class="sd">                                                 imputed</span>
<span class="sd">                        possible_vals (&#39;a list): A list of all possible values</span>
<span class="sd">                                                 that imp_var can take</span>
<span class="sd">    aux_vars (str * RBEISDistanceFunction dict): A dictionary whose keys are</span>
<span class="sd">                                                 strings corresponding to the</span>
<span class="sd">                                                 names of auxiliary variables</span>
<span class="sd">                                                 and whose values are the</span>
<span class="sd">                                                 RBEISDistanceFunctions to be</span>
<span class="sd">                                                 used to compare instances of</span>
<span class="sd">                                                 each auxiliary variable.</span>
<span class="sd">                                ratio (numeric): [Optional] Instead of choosing</span>
<span class="sd">                                                 the minimum distance, choose</span>
<span class="sd">                                                 records less than or equal to</span>
<span class="sd">                                                 ratio * the minimum distance.</span>
<span class="sd">                                in_place (bool): [Optional, default True] If</span>
<span class="sd">                                                 True, modify the original</span>
<span class="sd">                                                 DataFrame in place.  If False,</span>
<span class="sd">                                                 return a new (deep) copy of the</span>
<span class="sd">                                                 DataFrame having undergone</span>
<span class="sd">                                                 imputation.</span>
<span class="sd">                      keep_intermediates (bool): [Optional, default False] If</span>
<span class="sd">                                                 True, retain the intermediate</span>
<span class="sd">                                                 columns created by this</span>
<span class="sd">                                                 implementation of RBEIS in the</span>
<span class="sd">                                                 process of imputation.  If</span>
<span class="sd">                                                 False, remove them from the</span>
<span class="sd">                                                 output.</span>

<span class="sd">    Impute missing values for a given variable using the Rogers &amp; Berriman</span>
<span class="sd">    Editing and Imputation System (RBEIS).  By default, this function modifies</span>
<span class="sd">    the existing DataFrame in place, rather than returning a new DataFrame,</span>
<span class="sd">    unless in_place is set to False.  A high-level overview of the approach is</span>
<span class="sd">    given here (for more detail, see the documentation for each of the</span>
<span class="sd">    intermediate functions in this library):</span>
<span class="sd">    1. Identify values to be imputed</span>
<span class="sd">    2. Assign imputation groups (&quot;IGroups&quot;) based on a given set of auxiliary</span>
<span class="sd">       variables</span>
<span class="sd">    3. Calculate how similar the auxiliary variables of each IGroup are to those</span>
<span class="sd">       of the potential donor records</span>
<span class="sd">    4. Assign the most similar records to the donor pools of the corresponding</span>
<span class="sd">       IGroups</span>
<span class="sd">    5. Impute values for each IGroup</span>
<span class="sd">    6. Insert imputed values into the original DataFrame</span>

<span class="sd">    e.g. impute(pd.read_csv(&quot;my_data.csv&quot;),</span>
<span class="sd">                &quot;genre&quot;,</span>
<span class="sd">                [&quot;jungle&quot;, &quot;acid house&quot;, &quot;UK garage&quot;],</span>
<span class="sd">                {&quot;artist&quot;: RBEISDistanceFunction(1, weight = 5),</span>
<span class="sd">                 &quot;bpm&quot;: RBEISDistanceFunction(5, custom_map = {(170, 180): 0, (140, 160): 100}, threshold = 5),</span>
<span class="sd">                 &quot;length&quot;: RBEISDistanceFunction(2, threshold = 1.25)},</span>
<span class="sd">                ratio = 1.5,</span>
<span class="sd">                in_place = False,</span>
<span class="sd">                keep_intermediates = True)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Input checks</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Dataset must be a Pandas DataFrame&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">imp_var</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Imputation variable name must be a string&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">possible_vals</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Possible values must be contained in a list&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">possible_vals</span><span class="p">,</span><span class="n">data</span><span class="p">[</span><span class="n">imp_var</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()))</span><span class="o">+</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])):</span>
        <span class="k">raise</span> <span class="n">RBEISInputException</span><span class="p">(</span><span class="s2">&quot;The column to undergo imputation contains values that are not included in possible_vals&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">aux_vars</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;aux_vars must be a dictionary whose keys are strings representing auxiliary vvariables and whose values are RBEISDistanceFunctions&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="n">aux_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">()))):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;aux_vars must be a dictionary whose keys are strings containing auxiliary variable names&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">RBEISDistanceFunction</span><span class="p">),</span>
                <span class="n">aux_vars</span><span class="o">.</span><span class="n">values</span><span class="p">()))):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;aux_vars must be a dictionary whose values are RBEISDistanceFunctions&quot;</span>
        <span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">ratio</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ratio</span><span class="p">,</span> <span class="n">Number</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The ratio must be numeric&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ratio</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RBEISInputException</span><span class="p">(</span><span class="s2">&quot;The ratio must be greater than 1&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">in_place</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">in_place</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;in_place must be either True or False&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">keep_intermediates</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">keep_intermediates</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;keep_intermediates must be either True or False&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Imputation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">in_place</span><span class="p">):</span>
        <span class="n">data_old</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">_check_missing_auxvars</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">aux_vars</span><span class="p">)</span>
    <span class="n">_add_impute_col</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">imp_var</span><span class="p">)</span>
    <span class="n">_assign_igroups</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">aux_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">_calc_distances</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">aux_vars</span><span class="p">)</span>
    <span class="n">_calc_donors</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="n">ratio</span><span class="p">)</span>
    <span class="n">imputed_vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="nb">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">_impute_igroup</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">_freq_to_exp</span><span class="p">(</span>
                    <span class="n">data</span><span class="p">,</span> <span class="n">_get_freq_dist</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">imp_var</span><span class="p">,</span> <span class="n">possible_vals</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">),</span>
                <span class="n">possible_vals</span><span class="p">,</span>
                <span class="n">i</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="nb">range</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_IGroup&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span>
        <span class="p">))</span>
    <span class="n">data</span><span class="p">[</span><span class="n">imp_var</span> <span class="o">+</span> <span class="s2">&quot;_imputed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="p">(</span><span class="n">imputed_vals</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s2">&quot;_IGroup&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                   <span class="k">if</span> <span class="n">imputed_vals</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s2">&quot;_IGroup&quot;</span><span class="p">]]</span> <span class="o">!=</span> <span class="p">[]</span> <span class="k">else</span> <span class="n">r</span><span class="p">[</span><span class="n">imp_var</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="s2">&quot;_impute&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="n">r</span><span class="p">[</span><span class="n">imp_var</span><span class="p">],</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">l</span> <span class="o">==</span> <span class="p">[],</span> <span class="n">imputed_vals</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">keep_intermediates</span><span class="p">):</span>
        <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_impute&quot;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_IGroup&quot;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_distances&quot;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;_donor&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">in_place</span><span class="p">):</span>
        <span class="n">data_new</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">data_old</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">data_old</span>
        <span class="k">return</span> <span class="n">data_new</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search/" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex/" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../">rbeis 0.0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">rbeis.pandas</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, Phil Yeeles.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.4.
    </div>
  </body>
</html>